# -*- coding: utf-8 -*-
"""Student 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1up4Ph9qQfGM-n5WoBwyolgL8IZNEJDdZ
"""

#import libraries
import pandas as pd
import numpy as np
import sklearn.cluster as cluster
import sklearn.metrics as skmet
import matplotlib.pyplot as plt
import scipy.optimize as opt
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import seaborn as sns
from scipy.optimize import curve_fit
from scipy.stats import t
from sklearn.linear_model import LinearRegression
import scipy.stats
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import silhouette_score

def load_file(file_name):
    """
    # this function reads the dataset in csv format and load into panda dataframe
    # skip the first 4 rows, transpose the data and return both dataframes.

    Parameters:
    - file_name (str): name of the file.

    Returns:
    - df and transposed_df (dataFrame): dataframe and its transpose

    """
    df = pd.read_csv(file_name, skiprows=4)
    df_transpose = df.T

    return(df, df_transpose)

# Define the model function
def model(x, a, b, c):

  """ This function defines a model using a quadratic equation.

    - Parameters: x (float or array-like):
      The input value or array of input values. a, b, c (float):
      The coefficients of the quadratic equation.

    - Returns: float or array-like: The output value or array of output values

  """

  return a * x**2 + b * x + c

def top_five(df, indicator):
    """
    Plot the top 5 countries with the highest value for a specified indicator.

    Parameters:

    df (DataFrame): DataFrame containing the countries, indicators, and years.
    indicator (str): The indicator for which the top 5 countries should be plotted.

    Returns:

    None: The function only plots the graph.

    Examples:

    top_five(df, 'Population Density')
    """
    # Sorting in descending order
    data = df.sort_values(by='2021', ascending=False)

    # Top 10 countries
    top_countries = data.head(5)

    # Line plot data
    countries = top_countries['Country Name']
    indicator_data = top_countries['2020']

    # Plotting the line plot
    plt.figure(figsize=(13, 8))
    plt.plot(indicator_data, countries, 'or', marker='o')
    plt.xlabel(indicator)
    plt.ylabel('Country')
    plt.title(f'Top 5 Countries {indicator}\n2021', fontsize=18)
    plt.xticks(rotation=45)
    plt.grid(True)
    plt.show()

# Define function to calculate confidence ranges
def err_ranges(params, covariance, x_data, model):

        n = len(x_data)
        dof = max(0, n - len(params))  # degrees of freedom

        # Calculate standard deviations of parameters
        param_std_dev = np.sqrt(np.diag(covariance))

        # Calculate t-statistic for 95% confidence interval
        t_value = 2.262

        # Calculate confidence ranges
        lower_bounds = params - t_value * param_std_dev
        upper_bounds = params + t_value * param_std_dev

        return lower_bounds, upper_bounds

def preprocess_data(df):
    """
    This function preprocesses the input data by removing unnecessary columns
    and replacing NaN values with zeros.

    :param df: pandas DataFrame. The input data to be preprocessed.
    :return: pandas DataFrame. The preprocessed DataFrame with the
     unnecessary columns removed and NaN values replaced with zeros.
    """
    df = df.drop(["Unnamed: 67", "Country Code", "Indicator Code"], axis = 1)
    df.fillna(0, inplace=True)
    return df

def data_describe(df):
  """
   # this function describe the statistics about datafram

   - paramater: dataframe containing data

  """
  unique_values = df['Indicator Name'].unique()
  print(unique_values)
  print(df.head())
  print(df.info())
  print(df.describe())
  df.columns

  # Checking for missing values
  print(df.isna().sum())

def relevant_data(df, years, indicator, country):

    """
   # this function extract relevat data based on specific years, indicators and country

   - paramater: df (dataframe), years , indicator, country

   - return: filtered_df
   """

    # Filtering data for the indicator
    filtered_df = df[df["Indicator Name"] == indicator]
    filtered_df = filtered_df[filtered_df["Country Name"] == country]
    filtered_df = filtered_df[years]

    return filtered_df

def line_plot(df, years, label):
    """
    This function plots a line graph for the input dataframe using the specified years.

    :param df: pandas DataFrame. The input data to be plotted.
    :param years: list. The list of years to be plotted on the x-axis.
    :param label: str. The label for the y-axis of the plot.
    """

    # Plotting the line
    plt.figure(figsize=(14, 5))
    plt.plot(years, df.iloc[0], linestyle='--', marker='o', color='blue')

    # Set x-axis ticks at a 5-year interval
    plt.xticks(np.arange(0, len(years), 5), labels=years[::5])

    plt.xlabel('Year')
    plt.ylabel(label)
    plt.title(label, fontsize=20)

    plt.show()

def plot_bars(data, selected_Countries, years, indicator, title):
    """
    Plot a line graph for selected countries and years, visualizing the trend of an indicator.

    Parameters:

    data (DataFrame): DataFrame containing data for all countries and years.
    selected_Countries (list): List of country names to include in the plot.
    years (list): List of year names to include in the plot.
    indicator (str): The indicator to plot for each country.
    title (str): The title of the plot.

    Returns:

    None: The function only generates a line plot.

    """
    # Filter data for selected countries, years
    filtered_df = data[(data["Country Name"].isin(selected_Countries))][['Country Name'] + years]

    # Transpose the DataFrame for correct plotting orientation
    filtered_df_transposed = filtered_df.set_index('Country Name').T

    # Plotting a bar graph
    filtered_df_transposed.plot(kind= 'line', figsize=(10, 6), linestyle='--', marker='o')
    plt.title(f'{title}\n{indicator}',fontsize=20)
    plt.xlabel('Year')
    plt.ylabel(indicator)
    plt.legend(title='Country', bbox_to_anchor=(0.05, 1), loc='upper left')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

#Main function
gdp, gdp_countries = load_file("API_3_DS2_en_csv_v2_6303673.csv")
pop, pop_countries = load_file("API_SP.POP.GROW_DS2_en_csv_v2_6298705.csv")

data_describe(gdp)

gdp = preprocess_data(gdp)
pop = preprocess_data(pop)

country = 'World'
gdp_indicator = 'GDP per capita (current US$)'
pop_indicator = 'Population growth (annual %)'
years = [str(year) for year in range(1985, 2021)]
selected_gdp = relevant_data(gdp, years, gdp_indicator, country)
selected_pop = relevant_data(pop, years, pop_indicator, country)

line_plot(selected_gdp, years, gdp_indicator)
line_plot(selected_pop, years, pop_indicator)

# Filtering data for the indicator
gdp = gdp[gdp["Indicator Name"] == gdp_indicator]
gdp_orginal = gdp.copy()

# Choose the columns
selected_gdp = gdp.loc[:, '1980':'2018']

# Normalize the data
scaler = MinMaxScaler()
normalized_data = scaler.fit_transform(selected_gdp)

#To set up the number of clusters to perfom KMeans clustering
nclusters=3
kmeans=KMeans(nclusters,random_state=42)

#To fit the data
clusters = kmeans.fit_predict(normalized_data)

silhouettescores = silhouette_score(normalized_data, clusters)
print(f"Silhouette Score: {round(silhouettescores, 2)}")

# Add cluster labels to the DataFrame
gdp['Cluster'] = clusters

plt.figure(figsize=(6, 4))
col = ["tab:red", "tab:olive", "tab:cyan"]

# Visualize the results
for i in range(max(clusters) + 1):
    cluster_data = normalized_data[clusters == i]
    plt.scatter(cluster_data[:, 0], cluster_data[:, 1], label=f'Cluster {i + 1}', marker='*', s=10, color=col[i])
    plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], s=50, c='black', marker='X')

# Round cluster center values
cluster_centers_rounded = np.round(kmeans.cluster_centers_, 2)
plt.title(f"Clustering{gdp_indicator}",fontsize=20)
plt.xlabel("Countries")
plt.show()

# Filtering data for the indicator
gdp = gdp[gdp["Indicator Name"] == gdp_indicator]
gdp_orginal = gdp.copy()

# Choose the columns
selected_gdp = gdp.loc[:, '1980':'2018']

# Normalize the data
scaler = MinMaxScaler()
normalized_data = scaler.fit_transform(selected_gdp)

#To set up the number of clusters to perfom KMeans clustering
nclusters=3
kmeans=KMeans(nclusters,random_state=42)

#To fit the data
clusters = kmeans.fit_predict(normalized_data)

silhouettescores = silhouette_score(normalized_data, clusters)
print(f"Silhouette Score: {round(silhouettescores, 2)}")

# Add cluster labels to the DataFrame
#gdp['Cluster'] = clusters

# Back scale the normalized data to original values
back_scaled_data = scaler.inverse_transform(normalized_data)

# Add the back-scaled values to the original DataFrame
gdp.loc[:, '1980':'2018'] = back_scaled_data

# Add cluster labels to the DataFrame
gdp['Cluster'] = clusters

plt.figure(figsize=(6, 4))
col = ["tab:red", "tab:olive", "tab:cyan"]

# Visualize the results with original values
for i in range(max(clusters) + 1):
    cluster_data = back_scaled_data[clusters == i]
    plt.scatter(cluster_data[:, 0], cluster_data[:, 1], label=f'Cluster {i + 1}', marker='*', s=50, color=col[i])
    plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], s=100, c='black', marker='X')

# Round cluster center values
cluster_centers_rounded = np.round(scaler.inverse_transform(kmeans.cluster_centers_), 2)

plt.title(f"Clustering \n{gdp_indicator}", fontsize=20 )
plt.xlabel("GDP per Capita")
plt.ylabel("Year")
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import silhouette_score

# Filtering data for the indicator
gdp = gdp[gdp["Indicator Name"] == gdp_indicator]
gdp_original = gdp.copy()

# Choose the columns
selected_gdp = gdp.loc[:, 'Country Name':'2018']

# Normalize the data
scaler = MinMaxScaler()
normalized_data = scaler.fit_transform(selected_gdp.drop(['Country Name','Indicator Name'], axis=1))

#To set up the number of clusters to perfom KMeans clustering
nclusters=3
kmeans=KMeans(nclusters,random_state=42)

#To fit the data
clusters = kmeans.fit_predict(normalized_data)

silhouettescores = silhouette_score(normalized_data, clusters)
print(f"Silhouette Score: {round(silhouettescores, 2)}")

# Add cluster labels to the DataFrame
gdp['Cluster'] = clusters


plt.figure(figsize=(6, 4))
col = ["tab:red", "tab:olive", "tab:cyan"]

# Visualize the results
for i in range(max(clusters) + 1):
    cluster_data = selected_gdp[clusters == i]
    plt.scatter(cluster_data['Country Name'], cluster_data.iloc[:, -1], label=f'Cluster {i + 1}', marker='*', s=10, color=col[i])
    plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, -1], s=10, c='black', marker='X')

plt.title(f"Clustering \n{gdp_indicator}", fontsize=20)
plt.xlabel("Countries")
plt.ylabel(gdp_indicator)
plt.legend()
# Hide x-axis tick labels and tick marks
plt.xticks([])
plt.show()

country_name = "United States"
country_gdp = gdp[gdp['Country Name'] == country_name]
years = [str(year) for year in range(1985, 2021)]
#years = np.arange(2010, 2021)
x_data = country_gdp[years].values.flatten()
y_data = np.arange(len(years))

# Fit the model to the data using curve_fit
params, covariance = curve_fit(model, y_data, x_data)

# Calculate confidence ranges
lower_bounds, upper_bounds = err_ranges(params, covariance, y_data, model)

# Generate data for plotting the fitted curve
x_fit = np.linspace(min(y_data), max(y_data), 1000)
y_fit = model(x_fit, *params)

# Plot the data, the fitted curve, and the confidence range
plt.scatter(y_data, x_data, label='Data', color='black')
plt.plot(x_fit, y_fit, color='red', label='Fitted Curve')
plt.fill_between(x_fit, model(x_fit, *lower_bounds), model(x_fit, *upper_bounds),
                     color='skyblue', alpha=0.5, label='Confidence Range')

plt.xlabel('Year')
plt.ylabel(gdp_indicator)
plt.title(f'Curve Fitting for {country_name}',fontsize=20)
plt.legend()
plt.show()

#Comparison of countries from different clusters
# Specific years
years = ['1980', '1985', '1990','1995', '2000', '2005', '2010', '2015', '2020']

#selected_countries list
selected_countries = []
for i in range(max(clusters) + 1):
        cluster_data = gdp[gdp['Cluster'] == i]
        selected_country = cluster_data.iloc[0]['Country Name']
        selected_countries.append(selected_country)


# Plot selected countries within each cluster
for i, country in enumerate(selected_countries):

        cluster_data = gdp[gdp['Cluster'] == i]

        country_data = cluster_data[cluster_data['Country Name'] == country]

        # Select only the chosen years
        country_data_subset = country_data[['Country Name'] + years]

        # Plotting a line chart for the selected years
        plt.plot(country_data_subset.columns[1:], country_data_subset.iloc[0, 1:], label=f'{country} - Cluster {i + 1}', linestyle = '--', marker = '*')

# Customize the plot
plt.title(f"Countries from each Clusters \n{gdp_indicator}", fontsize=20)
plt.xlabel("Year")
plt.ylabel(f"{gdp_indicator}")

# Place the legend to the right outside the plot
plt.legend(title='Legend', bbox_to_anchor=(0.05, 1), loc='upper left')
plt.show()

# Select specific cluster countries
cluster_label = 2
cluster_data = gdp[gdp['Cluster'] == cluster_label]

# Choose countries from the cluster
cluster_countries = cluster_data.sample(min(4, len(cluster_data)))['Country Name'].tolist()

title = f'Countries in Cluster {(cluster_label+1)}'
plot_bars(gdp, cluster_countries, years, gdp_indicator, title)
plot_bars(pop, cluster_countries, years, pop_indicator, title)

title = 'Each Cluster Countries'
plot_bars(gdp_orginal, selected_countries, years, gdp_indicator, title)
plot_bars(pop, selected_countries, years, pop_indicator, title)

top_five(pop, pop_indicator)
top_five(gdp, gdp_indicator)

